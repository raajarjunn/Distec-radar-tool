<!-- apps/templates/Scorecard/Compendium.html -->
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Scorecard Compendium</title>
  <style>
    /* Keep layout width identical with/without scrollbars to avoid horizontal shift in the exported PDF */
    html, body { scrollbar-gutter: stable both-edges; }

    @page { size: A4 landscape; margin: 0; }

    /* One page per scorecard; don't force a blank page after the last one */
    .scorecard-container { 
      width: 297mm;                 /* lock to A4 landscape width */
      margin: 0 auto;               /* consistent centering */
      page-break-after: always; 
      break-after: page;
    }
    .scorecard-container:last-child {
      page-break-after: auto;
      break-after: auto;
    }

    body { margin:0; background:#fff; }

    .toolbar { 
      position: sticky; 
      top:0; 
      background:#fff; 
      padding:8px; 
      border-bottom:1px solid #e5e7eb; 
      display:flex; 
      gap:8px; 
      z-index: 10;
    }
    button { background:#045823; color:#fff; border:none; padding:8px 12px; cursor:pointer; }

    /* During export: hide toolbar and lock scrolling to prevent last-moment reflow/shift */
    body.exporting { overflow: hidden; }
    body.exporting .toolbar { display: none !important; }

   .pdf-row{display:flex;gap:8px;align-items:center;padding:6px 8px;border-bottom:1px solid #e5e7eb}
   .pdf-row input[type="number"]{width:110px}
   .pdf-row .name{flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
   .pdf-row .hint{color:#6b7280;font-size:12px}


  </style>
</head>
<body>

  <div class="toolbar">
    <button id="download">Download PDF</button>

    <!-- Choose multiple PDFs, then set positions -->
    <label style="display:inline-flex;align-items:center;gap:6px;">
      Insert PDF(s)
      <input type="file" id="pdfFiles" accept="application/pdf" multiple>
    </label>
  </div>

  <!-- List of selected PDFs with per-file "After page #" inputs -->
  <div id="pdfQueue" style="padding:8px 8px 0 8px;"></div>


  <div id="compendium">
    {{ combined_html|safe }}
  </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
<script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
<script>
  const filename = '{{ filename }}';

  // --- UI: manage the per-file "after page #" list ---
  const pdfInput  = document.getElementById('pdfFiles');
  const pdfQueue  = document.getElementById('pdfQueue');
  let queued = []; // [{id, file, afterPage: number|null}]

  pdfInput.addEventListener('change', () => {
    const startIndex = queued.length;
    const files = Array.from(pdfInput.files || []);
    files.forEach((file, i) => {
      const id = `f_${startIndex + i}`;
      queued.push({ id, file, afterPage: null }); // null = end
    });
    renderQueue();
    // Clear the <input> so user can add more later without replacing
    pdfInput.value = '';
  });

  function renderQueue(){
    pdfQueue.innerHTML = '';
    if (!queued.length) {
      pdfQueue.innerHTML = '<div class="hint" style="padding:6px 8px;">No extra PDFs selected.</div>';
      return;
    }
    queued.forEach((item, idx) => {
      const row = document.createElement('div');
      row.className = 'pdf-row';
      row.innerHTML = `
        <span class="name" title="${item.file.name}">${idx+1}. ${item.file.name}</span>
        <label>After page #
          <input type="number" min="0" step="1" placeholder="end" data-id="${item.id}">
        </label>
        <button type="button" data-remove="${item.id}">Remove</button>
        <span class="hint">0 = before first; 1 = after page 1; blank = end</span>
      `;
      pdfQueue.appendChild(row);
    });

    // Bind inputs
    pdfQueue.querySelectorAll('input[type="number"]').forEach(inp=>{
      inp.addEventListener('input', e => {
        const id = e.target.getAttribute('data-id');
        const it = queued.find(q => q.id === id);
        const v = e.target.value.trim();
        if (v === '') it.afterPage = null;           // end
        else {
          const n = parseInt(v, 10);
          it.afterPage = isNaN(n) ? null : Math.max(0, n); // clamp min 0
        }
      });
    });

    // Bind remove
    pdfQueue.querySelectorAll('button[data-remove]').forEach(btn=>{
      btn.addEventListener('click', e => {
        const id = e.target.getAttribute('data-remove');
        queued = queued.filter(q => q.id !== id);
        renderQueue();
      });
    });
  }
  renderQueue();

  // Utility: read File → ArrayBuffer
  function readFileAsArrayBuffer(file) {
    return new Promise((resolve, reject) => {
      const r = new FileReader();
      r.onload = () => resolve(r.result);
      r.onerror = reject;
      r.readAsArrayBuffer(file);
    });
  }

  // --- Build + merge ---
  document.getElementById('download').onclick = async function () {
    const element = document.getElementById('compendium');
    document.body.classList.add('exporting');

    const opt = {
      margin: 0,
      filename,
      image: { type: 'jpeg', quality: 0.98 },
      html2canvas: { scale: 1.5, useCORS: true, backgroundColor: '#ffffff' },
      jsPDF: { unit: 'mm', format: 'a4', orientation: 'landscape' },
      pagebreak: { mode: ['avoid-all', 'css', 'legacy'] }
    };

    try {
      // 1) Render compendium → jsPDF
      const jsPdf = await html2pdf().set(opt).from(element).toPdf().get('pdf');

      // 2) Your current behavior: delete every even page (optional)
      for (let i = jsPdf.internal.getNumberOfPages(); i >= 2; i--) {
        if (i % 2 === 0) jsPdf.deletePage(i);
      }

      // 3) Convert to bytes and load with pdf-lib
      const mainBytes = jsPdf.output('arraybuffer');
      const mainDoc = await PDFLib.PDFDocument.load(mainBytes);

      // 4) Build an insertion plan:
      //    - afterPage is 1-based semantic: "after page N" → insert at index N
      //    - 0 means before first → index 0
      //    - null means "end" → we’ll treat as Infinity to sort to the end
      const plan = queued.map((q, idx) => ({
        idx,                       // stable tie-breaker
        file: q.file,
        pos: (q.afterPage === null ? Infinity : q.afterPage) // 0..∞
      }))
      // sort by position ascending; equal positions keep original order
      .sort((a,b) => (a.pos - b.pos) || (a.idx - b.idx));

      // 5) Execute the plan
      //    We insert in sorted order and compute the 0-based insert index
      //    against the *current* page count each time.
      for (const step of plan) {
        const buf = await readFileAsArrayBuffer(step.file);
        const extraDoc = await PDFLib.PDFDocument.load(buf);
        const pages = await mainDoc.copyPages(extraDoc, extraDoc.getPageIndices());

        // Current page count *before* inserting this file
        const currentCount = mainDoc.getPageCount();

        // Determine insert index:
        // pos = Infinity → append at end
        // pos = 0 → before first page (index 0)
        // pos = N → after page N → index = clamp(N, 0..currentCount)
        const index0 = (step.pos === Infinity)
          ? currentCount
          : Math.min(Math.max(0, step.pos), currentCount);

        pages.forEach((p, i) => mainDoc.insertPage(index0 + i, p));
        // page count automatically grows; next iteration sees updated count
      }

      // 6) Save merged and download
      const mergedBytes = await mainDoc.save();
      const blob = new Blob([mergedBytes], { type: 'application/pdf' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      a.click();
      URL.revokeObjectURL(a.href);
    } catch (err) {
      console.error(err);
      alert('Failed to build PDF. See console for details.');
    } finally {
      document.body.classList.remove('exporting');
    }
  };
</script>


</body>
</html>
